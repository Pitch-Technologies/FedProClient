/***********************************************************************
  Copyright (C) 2023 Pitch Technologies AB

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 **********************************************************************/

#pragma once

#include <services-common/ClientConverter.h>
#include <services-common/protobuf_util.h>

#include <gtest/gtest.h>

#include <array>
#include <type_traits>

namespace FedPro
{
   template <class T>
   struct is_smart_pointer : std::false_type
   {
   };

   template <class T>
   struct is_smart_pointer<std::shared_ptr<T>> : std::true_type
   {
   };

   template <class T, class DestructorType>
   struct is_smart_pointer<std::unique_ptr<T, DestructorType>> : std::true_type
   {
   };
}


// TestClientConverter acts as base class for ClientConverter test fixtures.
// This class provides utility functions, and generic test functions.
class TestClientConverter : public ::testing::Test
{
protected:

   // Transform a type by removing const and volatile qualifiers, reference, and pointer;
   template<typename T>
   struct remove_cvrefpointer : std::remove_pointer<std::remove_cv_t<std::remove_reference_t<T>>>
   {
   };

   template<typename T>
   using remove_cvrefpointer_t = typename remove_cvrefpointer<T>::type;

   // Make a copy of the object provided as pointer, then delete the original.
   template<typename T, typename ParamT, typename std::enable_if_t<std::is_convertible<ParamT, T *>::value, bool> = true>
   static auto make_object(ParamT pointer)
   {
      // Take ownership of the pointer, to delete it on return.
      std::unique_ptr<T> smartPointer(pointer);
      return T(*smartPointer);
   }

   // Make a copy of the object provided as std::unique_ptr.
   template<typename T, typename ParamT, typename std::enable_if_t<FedPro::is_smart_pointer<T>::value, bool> = true>
   static auto make_object(ParamT smartPointer)
   {
      return T(*smartPointer);
   }

   // Make a copy of the provided object.
   template<typename T, typename ParamT, typename std::enable_if_t<std::is_same<ParamT, T>::value, bool> = true>
   static auto make_object(const ParamT & object)
   {
      return T(object);
   }

   // Obtain a const-ref to an object passed as a pointer.
   template<typename ParamT, typename std::enable_if_t<std::is_pointer<ParamT>::value, bool> = true>
   static const std::remove_pointer_t<ParamT> & as_cref(const ParamT pointer)
   {
      return *pointer;
   }

   // Obtain a const-ref to an object passed as a smart pointer.
   template<typename ParamT, typename std::enable_if_t<FedPro::is_smart_pointer<ParamT>::value, bool> = true>
   static const typename ParamT::element_type & as_cref(const ParamT & smartPointer)
   {
      return *smartPointer;
   }

   // Obtain a const-ref to an object passed as-is.
   template<typename ParamT,
         typename std::enable_if_t<std::is_class<ParamT>::value, bool> = true,
         typename std::enable_if_t<!FedPro::is_smart_pointer<ParamT>::value, bool> = true>
   static const ParamT & as_cref(const ParamT & objectRef)
   {
      return objectRef;
   }

   // Obtain a const-ref to a built-in arithmetic or enum value passed as-is.
   template<typename ParamT,
         typename std::enable_if_t<std::integral_constant<bool, std::is_arithmetic<ParamT>::value || std::is_enum<ParamT>::value>::value, bool> = true>
   static const ParamT & as_cref(const ParamT & objectRef)
   {
      return objectRef;
   }

   ~TestClientConverter() override = default;

   // Test ClientConverter methods convertFromHla then convertToHla,
   // with values generated by createValidInstances() and createInvalidInstances.
   template<typename RTIType>
   void test_convertFrom_convertTo()
   {
      // Return type (minus pointer/const/volatile) for ClientConverter::convertFromHla(RTIType)
      using FedProConvertType = remove_cvrefpointer_t<decltype(_clientConverter.convertFromHla(std::declval<RTIType>()))>;

      // Test converting valid values back-and-forth.
      test_convertFrom_convertTo<RTIType, FedProConvertType>();
   }

   // Test ClientConverter methods convertFromHla then convertToHla,
   // with values generated by createValidInstances() and createInvalidInstances.
   template<typename RTIType, typename FedProConvertT>
   void test_convertFrom_convertTo() const
   {
      for (const auto & rtiInstance : createValidInstances<RTIType>()) {
         RTIType tmpRtiInstance{rtiInstance};

         // Use make_object<>() to obtain an object, even if the conversion produces a raw pointer or std::unique_ptr<>.
         auto fedProInstance = make_object<FedProConvertT>(_clientConverter.convertFromHla(std::move(tmpRtiInstance)));
         auto rtiInstanceBis = _clientConverter.convertToHla(std::move(fedProInstance));

         EXPECT_EQ(rtiInstance, as_cref(rtiInstanceBis));
      }

      for (auto & invalidRtiInstance : createInvalidInstances<RTIType>()) {
         EXPECT_THROW(_clientConverter.convertFromHla(std::move(invalidRtiInstance)), RTI_NAMESPACE::RTIinternalError);
      }

      for (auto & invalidFedproInstance : createInvalidInstances<FedProConvertT>()) {
         EXPECT_THROW(_clientConverter.convertToHla(std::move(invalidFedproInstance)), RTI_NAMESPACE::RTIinternalError);
      }
   }

   // Test ClientConverter methods convertFromHla,
   // with values generated by createValidInstances() and createInvalidInstances.
   template<typename RTIType>
   void test_convertFromHla() const
   {
      for (const auto & rtiInstance : createValidInstances<RTIType>()) {
         RTIType rtiInstanceCopy{rtiInstance};
         EXPECT_NO_THROW(auto * fedProInstance = _clientConverter.convertFromHla(rtiInstanceCopy);
                               delete fedProInstance;);
      }

      for (auto & invalidRtiInstance : createInvalidInstances<RTIType>()) {
         EXPECT_THROW(_clientConverter.convertFromHla(std::move(invalidRtiInstance)), RTI_NAMESPACE::RTIinternalError);
      }
   }

   // Test method ClientConverter::convertFromHla with federate protocol protobuf objects
   // generated by createValidInstances()
   template<typename FedproT>
   void test_convertToHla() const
   {
      for (auto fedproInstance : createValidInstances<FedproT>()) {
         EXPECT_NO_THROW(_clientConverter.convertToHla(std::move(fedproInstance)));
      }

      for (auto & invalidFedproInstance : createInvalidInstances<FedproT>()) {
         EXPECT_THROW(_clientConverter.convertToHla(std::move(invalidFedproInstance)), RTI_NAMESPACE::RTIinternalError);
      }
   }

   // Create valid instances of a given type.
   // This generic implementation create one instance using the default constructor.
   // Derived test classes may specialize this function for specific types.
   template<typename T>
   inline auto createValidInstances() const
   {
      return std::array<T, 1>{{T{}}};
   }

   // Create invalid instances of a given type.
   // This generic implementation create no instances.
   // Derived test classes may specialize this function for specific types.
   template<typename T>
   constexpr auto createInvalidInstances() const
   {
      // T may be a pure virtual class that cannot be stored in a container.
      // So return a empty boolean list instead.
      return std::initializer_list<bool>{};
   }

   FedPro::ClientConverter _clientConverter;

};